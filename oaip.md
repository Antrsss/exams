# Вопросы к ОАиПу сиквел

## 1. Понятие сложности алгоритма, оценки времени исполнения.
### Временная сложность
Временная сложность алгоритма определяется как функция от размера данных и равна времени работы алгоритма на данном вводе.  
Чаще всего выражается в нотации Ландау (О-большое), в которой учитываются только слагаемые высших порядков и не учитываются константные множители. Такое определение временной сложности называется асимптотическим. Асимптотическая оценка временной сложности алгоритма корректна только для ввода, размер которого стремится к бесконечности.  
Временная сложность вычисляется путем подсчета количества элементарных операций, время выполнения каждой из которых -- О(1).  
В данной нотации существуют также обозначения Θ(n), Ω(n), T(n).
- T(n) обозначает количество всех действий, выполненных алгоритмом 
- Θ(n) обозначает нижнюю оценку. Если алгоритм требует Θ(log(n)) операций, то он требует не менее k*log(n) операций, где k -- некоторая константа.
- O(n) обозначает верхнюю оценку. Если алгоритм требует O(log(n)) операций, то он требует не более k*log(n) операций, где k -- некоторая константа.
- Ω(n) обозночает точную оценку. Если алгоритм требует Ω(log(n)) операций, то он требует не более k1*log(n) операций и не менее k2\*log(n) операций, где k1, k2 -- некоторые константы.

| Название | Время работы (T(n)) | Пример алгоритма|
| --------------- | --------------- | --------------- |
| константное | О(1) | побитовый сдвиг числа на 1 |
| дважды логарифмическое| O(log(log(n))) | интерполяционный поиск при равномерном распределении |
| логарифмическое | O(log(n)) | поиск в двоичном дереве поиска |
| линейное | O(n) | поиск наибольшего элемента в неотсортированном массиве |
| линейно-логарифмическое | O(n*log(n)) | наиболее быстрая сортировка сравнением |
| квадратичное | O(n²) | сортировка пузырьком |
| кубическое | O(n³) | обычное умножение матриц |
| экспоненциальное | 2^P(n)* | *P(n) - произвольный многочлен от n|
| факториальное | O(n!) | решение задачи комивояжера полным перебором |

### Пространственная сложность
Пространственная сложность алгоритма определяется аналагично временной, но показвыает объем используемой памяти. Например если алгоритм не использует дополнительной памяти (или использует ее бесконечно мало в сравнении с размером данных), то его пространственная сложность О(1). Например это нахождение наименьшего элемента в неотсортированном массиве.  
Пространственная сложность O(n^2) может возникнуть, если мы имеем функцию f(x,y), где x, y <= n и ее вычисление -- долгий процесс. Тогда вместо вычисления при каждой необходимости можно завести таблицу размера n*n, и  заполнять ее по необходимости.
## 2. Общая классификация вычислительных алгоритмов.
Под "вычислительными" алгоритмами понимаются алгоритмы, используемые для вычисления некоторых математических объектов. Условно их можно поделить на использующие целочисленные значения алгоритмы и алгоритмы, использующие значения с плавающей точкой.  
Вычислительные алгоритмы также можно разделить по области применения:
| Область применения   | Пример алгоритмов |
|--------------- | --------------- |
| теория чисел, вычисление констант и распространенных функций | проверка числа на простоту, разложение числа на множители |
| решение алгебраических задач   | решение СЛАУ  |
| нахождение корней различных уравнений   | решение диффиренциальных уравнений, задачи линейного программирования   |
| приближенное вычисление функций   | приближение функции методом наименьших квадратов |
| вычислительная геометрия  | задача о нахождении площади произвольного многоугольника или класс задач о взаимном расположении фигур |

>я блять хз что тут еще написать

## 3. Точность представления чисел.
Вещественные числа в языке С++ представлены типами float, double и long double, занимающими 4, 8 и 10 байт соответственно (вообще ldouble занимает 16 байт по причине выравнивание). Данные, хранимые в переменных данных типов в памяти представлены согласно стандарту IEEE754. 
>сами про стандарт пишите, мне впадлу

Таким образом тип float имеет 23 значимых для точности бита, тип double имеет 52, а тип long double -- 64. По этой причине проводить операции сравнения со значениями данных типов следует с осторожностью и по возможности лучше использовать выражения вида:
```cpp
long long x = some_func();
if(x - 1e-4 > 0.0001){
    do_sth();
}
```
## 4. Строковый тип в С++. Представление в памяти. Автоматическое управление памятью для Си строк и `std::string`.
Для представления текстовых данных в языке Си использовались массивы типа char, называемые Си строками. Индикатором их конца служил символ '\\0'. В языке С++ также можно пользоваться строками данного формата, но для повышения удобства работы с текстовыми данными стандартная библиотека содержит класс `std::string`. Данный класс содержит указатель на хранимый текст а также размер строки и объем выделенной памяти. Если для `std::string` автоматическое управление памятью реализованно с помощью механизмов ООП, таких как конструктор и деструктор, которые инкапсулируют выделение памяти, то автоматизация управления памятью для Си строк возможна через механизм умных указателей.  
Умные укзазатели представляют собой класс-обертку над обычным указателем. Существует три вида умных указателей: `unique_ptr`, `shared_ptr`, `weakй_ptr`.
### unique_ptr
`unique_ptr` представляет собой умный указатель, единолично владеющий своим ресурсом. Таким образом никакой другой указатель не может указывать на этот же объект (можно сделать 2 юник_птр из двух сишных поинтеров на один и тот же объект, но это УБ, моветон и долбоебизм). Поэтому данный класс реализует только конструктор перемещения и оператор присваивания-перемещением. Поведение при перемещении определено явно.
### shared_ptr
`shared_ptr` представляет собой умный указатель с разделенным владением. На объект может ссылаться неограниченное число `shared_ptr` и `weak_ptr`, при уничтожении последнего `shared_ptr` на объект (выход из области видимости, ручное удаление) память, выделенная на него освобождается. Для этого в каждом экземпляре хранится счетчик, показывающий количество указывающих на объект `shared_ptr`. 
### weak_ptr
`weak_ptr` представляет собой умный указатель с разделенным владением. Он создан для решения проблемы зацикливания в динамических структурах. Представим ситуацию:   
Имеется двусвязный список с подобной структурой:
```cpp
struct Node{
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev;
    T value;
};
```
Тогда если мы захотим удалить некоторый постфикс данного списка мы просто сменим указательв последнем нужном узле на `nullptr`. Но тогда возникнет проблема. Первый элемент постфикса не удалится, потму что на него ссылается следующий элемент. Но тогда не удалится и следующий. Получаем утечку памяти.   
Для решения данной проблемы были созданы слабые указатели. Перепишем узел следующим образом:
```cpp
struct Node{
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;
    T value;
}
```
При потере последнего `shared_ptr` на объект он удалится независимо от количества слабых указателей на него.
## 5. Файлы. Двоичное и текстовое представление файлов. Стандартные файлы.
## 6.  Понятие потока. Открытие и закрытие файлов. Операции ввода-вывода. Указатель чтения-записи в файле. 
## 7. Проверка операций ввода-вывода. Пример.
без комментариев пока что
## 8. Функции для модификации содержимого файла: futc, getc, feof, fputs, fgets, fprintf, fscanf, rewind.
## 9. Функции для модификации содержимого файла: ferror, fwrite, fread, fileno, filelength, chsize, ftell, fgetpos, fseek.
## 10. Типы данных – простые и составные. Агрегирование данных.
## 11. Указатели и ссылки в языке С++. Семантика копирования и перемещения.
## 12. Функции в языке С++. Понятие метода. Рекурсия.
## 13. Указатели на функции в языке С++.
## 14. Библиотечные модули пользователя. Назначение модуля. Структура модуля. Синтаксис и назначение разделов модуля. Пример.
## 15. Программирование статистических и динамических библиотек. Подключение в различных средах.
## 16. Статические и динамические структуры данных. Последовательности и динамические массивы. Реализация операций над последовательностями.
## 17. Линейные списки – основные операции. Реализация списков на основе динамических структур.
## 18. Двусвязный список и его программная реализация. Кольцевые списки. Упорядоченные списки и перестройка списков.
## 19. Понятие стека. Операции над стеком. Программная реализация стека на основе статического массива.
## 20. Понятие очереди. Операции над очередями. Кольцевая очередь. Деки. Программная реализация очереди на основе статического массива.
## 21. Использование очередей при реализации запросов ввода-вывода Структура данных «список».
## 22. Программная реализация очереди на основе статического массива.
## 23. Многократный поиск на основе использования статистических данных.
## 24. Нечеткий поиск – поиск «подобной» подстроки. Бинарный поиск.
## 25. Рекурсия: общий вид, свойства, проблемы. Стек вызова функций.
## 26. Сортировки – общая классификация. Сортировки с помощью включения, выделения, обменов.
## 27. Шейкерная сортировка. Сортировка Шелла.
## 28. Сортировка Хоара – алгоритм QuickSort. Сортировка слиянием.
## 29. Бинарные деревья – основные понятия. Основные операции с бинарными деревьями.
## 30. Понятие рекурсивного типа данных.
В информатике рекурсивными типами данных называются типы данных, которые могут содержать значения, принадлежащие этому же типу данных. Примером может служить структура Node, представляющая собой узел односвязного списка.
```cpp
struct Node{
    T value;
    Node* next;
}
```
Также рекурсивным типом данных считается узел дерева.
```cpp
struct TreeNode{
    std::pair<K,V> kv;
    TreeNode* parent;
    TreeNode* left;
    TreeNode* right;
}
```
## 31. Поиск и включение для деревьев. Исключение для деревьев.
## 32. Сбалансированные деревья. Сортировка с помощью бинарных деревьев (кучи).
## 33. Графы и возможные формы их описания. Нахождение кратчайшего пути на графе.
## 34. Алгоритм Дейкстры, алгоритм Форда.
## 35. Графовые алгоритмы – обзор.
## 36. Хеширование, проблемы коллизий.
## 37. Методы обработки коллизий в хешировании.
## 38. Хеш-таблица на основе перемешанной таблицы
## 39. Хеш-таблица на основе связанных списков
## 40. Построение обратной польской записи выражения.
## 41. Подходы и инструменты к отладке исходного кода
## 42. Директивы подпрограмм. Неявная рекурсия. Пример.
