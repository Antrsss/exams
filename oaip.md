# Вопросы к ОАиПу сиквел

## 1. Понятие сложности алгоритма, оценки времени исполнения.
### Временная сложность
Временная сложность алгоритма определяется как функция от размера данных и равна времени работы алгоритма на данном вводе.  
Чаще всего выражается в нотации Ландау (О-большое), в которой учитываются только слагаемые высших порядков и не учитываются константные множители. Такое определение временной сложности называется асимптотическим. Асимптотическая оценка временной сложности алгоритма корректна только для ввода, размер которого стремится к бесконечности.  
Временная сложность вычисляется путем подсчета количества элементарных операций, время выполнения каждой из которых -- О(1).  
В данной нотации существуют также обозначения Θ(n), Ω(n), T(n).
- T(n) обозначает количество всех действий, выполненных алгоритмом 
- Θ(n) обозначает нижнюю оценку. Если алгоритм требует Θ(log(n)) операций, то он требует не менее k*log(n) операций, где k -- некоторая константа.
- O(n) обозначает верхнюю оценку. Если алгоритм требует O(log(n)) операций, то он требует не более k*log(n) операций, где k -- некоторая константа.
- Ω(n) обозночает точную оценку. Если алгоритм требует Ω(log(n)) операций, то он требует не более k1*log(n) операций и не менее k2\*log(n) операций, где k1, k2 -- некоторые константы.

| Название | Время работы (T(n)) | Пример алгоритма|
| --------------- | --------------- | --------------- |
| константное | О(1) | побитовый сдвиг числа на 1 |
| дважды логарифмическое| O(log(log(n))) | интерполяционный поиск при равномерном распределении |
| логарифмическое | O(log(n)) | поиск в двоичном дереве поиска |
| линейное | O(n) | поиск наибольшего элемента в неотсортированном массиве |
| линейно-логарифмическое | O(n*log(n)) | наиболее быстрая сортировка сравнением |
| квадратичное | O(n²) | сортировка пузырьком |
| кубическое | O(n³) | обычное умножение матриц |
| экспоненциальное | 2^P(n)* | *P(n) - произвольный многочлен от n|
| факториальное | O(n!) | решение задачи комивояжера полным перебором |

### Пространственная сложность
Пространственная сложность алгоритма определяется аналагично временной, но показвыает объем используемой памяти. Например если алгоритм не использует дополнительной памяти (или использует ее бесконечно мало в сравнении с размером данных), то его пространственная сложность О(1). Например это нахождение наименьшего элемента в неотсортированном массиве.  
Пространственная сложность O(n^2) может возникнуть, если мы имеем функцию f(x,y), где x, y <= n и ее вычисление -- долгий процесс. Тогда вместо вычисления при каждой необходимости можно завести таблицу размера n*n, и  заполнять ее по необходимости.
## 2. Общая классификация вычислительных алгоритмов.
Под "вычислительными" алгоритмами понимаются алгоритмы, используемые для вычисления некоторых математических объектов. Условно их можно поделить на использующие целочисленные значения алгоритмы и алгоритмы, использующие значения с плавающей точкой.  
Вычислительные алгоритмы также можно разделить по области применения:
| Область применения   | Пример алгоритмов |
|--------------- | --------------- |
| теория чисел, вычисление констант и распространенных функций | проверка числа на простоту, разложение числа на множители |
| решение алгебраических задач   | решение СЛАУ  |
| нахождение корней различных уравнений   | решение диффиренциальных уравнений, задачи линейного программирования   |
| приближенное вычисление функций   | приближение функции методом наименьших квадратов |
| вычислительная геометрия  | задача о нахождении площади произвольного многоугольника или класс задач о взаимном расположении фигур |

>я блять хз что тут еще написать

## 3. Точность представления чисел.
Вещественные числа в языке С++ представлены типами float, double и long double, занимающими 4, 8 и 10 байт соответственно (вообще ldouble занимает 16 байт по причине выравнивание). Данные, хранимые в переменных данных типов в памяти представлены согласно стандарту IEEE754. 
>сами про стандарт пишите, мне впадлу

Таким образом тип float имеет 23 значимых для точности бита, тип double имеет 52, а тип long double -- 64. По этой причине проводить операции сравнения со значениями данных типов следует с осторожностью и по возможности лучше использовать выражения вида:
```cpp
long long x = some_func();
if(x - 1e-4 > 0.0001){
    do_sth();
}
```
## 4. Строковый тип в С++. Представление в памяти. Автоматическое управление памятью для Си строк и `std::string`.
Для представления текстовых данных в языке Си использовались массивы типа char, называемые Си строками. Индикатором их конца служил символ '\\0'. В языке С++ также можно пользоваться строками данного формата, но для повышения удобства работы с текстовыми данными стандартная библиотека содержит класс `std::string`. Данный класс содержит указатель на хранимый текст а также размер строки и объем выделенной памяти. Если для `std::string` автоматическое управление памятью реализованно с помощью механизмов ООП, таких как конструктор и деструктор, которые инкапсулируют выделение памяти, то автоматизация управления памятью для Си строк возможна через механизм умных указателей.  
Умные укзазатели представляют собой класс-обертку над обычным указателем. Существует три вида умных указателей: `unique_ptr`, `shared_ptr`, `weakй_ptr`.
### unique_ptr
`unique_ptr` представляет собой умный указатель, единолично владеющий своим ресурсом. Таким образом никакой другой указатель не может указывать на этот же объект (можно сделать 2 юник_птр из двух сишных поинтеров на один и тот же объект, но это УБ, моветон и долбоебизм). Поэтому данный класс реализует только конструктор перемещения и оператор присваивания-перемещением. Поведение при перемещении определено явно.
### shared_ptr
`shared_ptr` представляет собой умный указатель с разделенным владением. На объект может ссылаться неограниченное число `shared_ptr` и `weak_ptr`, при уничтожении последнего `shared_ptr` на объект (выход из области видимости, ручное удаление) память, выделенная на него освобождается. Для этого в каждом экземпляре хранится счетчик, показывающий количество указывающих на объект `shared_ptr`. 
### weak_ptr
`weak_ptr` представляет собой умный указатель с разделенным владением. Он создан для решения проблемы зацикливания в динамических структурах. Представим ситуацию:   
Имеется двусвязный список с подобной структурой:
```cpp
struct Node{
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev;
    T value;
};
```
Тогда если мы захотим удалить некоторый постфикс данного списка мы просто сменим указательв последнем нужном узле на `nullptr`. Но тогда возникнет проблема. 
Первый элемент постфикса не удалится, потму что на него ссылается следующий элемент. Но тогда не удалится и следующий. Получаем утечку памяти.   
Для решения данной проблемы были созданы слабые указатели. Перепишем узел следующим образом:
```cpp
struct Node{
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;
    T value;
}
```
При потере последнего `shared_ptr` на объект он удалится независимо от количества слабых указателей на него.  
Производительность программ с использованием умных указателей отличается от программы использующей обычные указатели незначительно (единственное место потерь это подсчет ссылок в `shared_ptr`)
## 5. Файлы. Двоичное и текстовое представление файлов. Стандартные файлы.
Файл - именованый набор байт, записанный на некотором носителе. Для работы с файлами в языке С++ определены потоки ввода-вывода.

>определение потока из следующего надо сюда вставить.

Файл можно представить в виде текста в некоторой кодировке. Подобное представление файла называется текстовым.
Наименьшей смысловой единицей в таких файлах служит один символ. Они обеспечивают удобство работы с текстовыми данными, но неэффективны, если требуется хранитьданные не текстового формата. 
Например запись числа 255 в кодировке utf-8 займет в текстовом формате 3 байта.   
Также файл можно представить как набор байт. В данном формате можно хранить данные напрямую в их двоичном представлении, от этого и название "бинарный файл".
Данный вид файлов позволяет хранить данные более эффективно, например запись числа 255 займет всего 1 байт.
Однако эта эффективность достигается ограничениями на работу. Например нужно либо ввести разделитель -- некоторый символ, или  последовательность байт, обозначающую конец элемента, либо знать точное количество байт, на которых записана нужная информация.
## 6.  Понятие потока. Открытие и закрытие файлов. Операции ввода-вывода. Указатель чтения-записи в файле.
### Понятие потока
Поток (тот что английский `stream`, не `thread`) - абстракция, представляющая собой устройство ввода/вывода. В общем и целом это бесконечный поток байт, который является либо источником, либо назначением. 
Чаще всего потоки связаны с физическим источником данных (файл, клавиатура, консоль). 
В языке С++ потоки буфферизированы, то есть имеют буффер, который хранит в себе введенную/выведенную информацию некоторое время после операции и только потом записывает/считывает ее. Например если посмотреть за файлом `text.txt` во время выполнения данного фрагмента кода, можнно заметить, что после записи в поток файл обновится не сразу.
```cpp
std::ofstream os;
os.open("text.txt");
os << "AAAAAAAAAAA"; //<- смотрим здесь
os.flush(); //<- и здесь
```
Сделано это для оптимизации, так как множественное обращение к файлу для чтения/записи затратно. Поэтому поток буфферизирует ввод/вывод.
### Открытие/закрытие файлов
Для потоков открытие файлов происходит с помощью метода open класса `basic_fstream`.
Данный метод вызывается с параметрами `filename` и `mode`, где первый это полное имя файла, второй -- режим открытия. 
| Константа   | Суть |
|--------------- | --------------- |
| app   | append, открыть для дозаписи в конец |
| binary   | открыть в режиме двоичного файла |
| in   | открыть для записи |
| out   | открыть для чтения |
| trunc | удалить содержимое файла при открытии |
| ate | выставить начальную позицию для записи в конец|
| noreplace | не позволяет открыть файл, если он существует, но не указаны флаги app или ate   |

>разница между ate и app заключается в том, что ate выставляет указаетль в конец однократно, а app перед каждой операцией ввода

Режимы открытия представлены числовыми константами.
### Операции ввода-вывода
Для совершения операций ввода-вывода для потоков перегружены операторы `>>` и `<<`, для потоков ввода и вывода соответственно.
Для потоков ввода-вывода определены таже форматирующие метод, флаги и манипуляторы (если надо опять писать про эти модификаторы сиаута я хочу умереть)
### Указатель чтения-записи в файле
Указатель чтения-записи представляет собой 64-разрядное значение смещения от начала файла до следующего байта для чтения-записи.
При открытии файла данное значение устанавливается равным нулю если не было установлено иное правило.

## 7. Проверка операций ввода-вывода. Пример.
без комментариев пока что
## 8. Функции для модификации содержимого файла: futc, getc, feof, fputs, fgets, fprintf, fscanf, rewind.
| Функция   | Сигнатура | Возвращаемое значение |Пояснение    |
|--------------- | --------------- |--------------- | --------------- |
| fputc   | int fputc(int ch, FILE* stream)   | значение записанного символа (при успехе), EOF при неудаче, также выставляет индикатор ошибки в потоке |   записывает символ в Си поток в позицию, соответствующую текущему значению указателя ввода-вывода|
| fgetc  |  int fgetc(FILE* stream) |  прочитанный символ или EOF (в случае достижения конца файла выставляет индикатор EOF, в ином случае индикатор ошибки)|считывает следующий символ из потока по указателю ввода-вывода и переводит его в следующую позицию|
| feof | int feof(FILE* stream)   |  ноль, если не был достигнут конец потока, иначе не ноль| проверка на EOF (End Of File кто не знал вдруг)|
| fputs   | int fputs(const char* str, FILE* stream) |  при успехе неотрицательное значение, при неудаче EOF и выставляет индикатор ошибки   |записывает все символы строки str кроме нуль-терминатора в поток|
| fgets   |  char* fgets(char* str, int count, FILE*)   |  str в случае успеха, nullptr в случае неудачи   |читает не более `count - 1` символов из потока и записывает их в массив символов представленный параметром `str`. При встрече символа перехода на следующую строку чтение обрывается и в строку записывается символ перехода на следующую строку. Если байты были прочитаны, записывает в конец строки нуль-терминатор|
| fprintf   | int fprintf(FILE* stream, const char* format, ...)  |  количество записаных символов при успехе, отрицательное число при ошибке| записывает данные в поток в соответствии с форматом, указанным в параметрах |
| fscanf   | int fscanf(FILE* stream, const char* format, ...) |  количество считаных аргументов в случае успеха, EOF в случае ошибки | считывает данные из потока, интерпретирует их в соответствии с форматирущей строкой |
| rewind   |  void rewind(FILE* stream) | void | переводит указатель ввода-вывода в начало потока (эквивалентна fseek(stream, 0, SEEK_SET), но дополнительно очищает идентификаторы ошибки и конца файла);    |

Перечисленные функции являются унаследованными от языка Си и не рекомендуются к использованию без явной на то необходимости. 

## 9. Функции для модификации содержимого файла: ferror, fwrite, fread, fileno, filelength, chsize, ftell, fgetpos, fseek.
| Функция   | Сигнатура | Возвращаемое значение |Пояснение    |
|--------------- | --------------- |--------------- | --------------- |
| ferror | int ferror(FILE* stream) | ненулевое значение если установлен идентификатор ошибки, иначе 0 | проверяет поток на ошибку |
| fwrite | size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream) | количество записаных объектов <= `count` | записывает `count` объектов байтами, размер объекта указывается в `size`. Если объект не является тривиально копируемым, то поведение не определено|
| fread | size_t fread(void* buffer, size_t size, size_t count, FILE* stream) | количество считаных объектов| считывает count объектов из потока, каждый в виде массива байт. Если объект не является тривиально копируемым, то поведение не определено |
| fileno | int fileno(FILE* stream)| системный дескриптор файла при успехе, иначе -1 и выставит идентификатор ошибки | возвращает дескриптор файла (как же я хочу чтобы меня при изучении С++ спрашивали про сишные функции, еще и с ОСной хуйнёй типа дескрипторов 🥰 кста почему-то этой функции нет на cppreference, хотя она существует до сих пор...) |
| filelength |  | | |
| chsize | | | |
| ftell   | | | |
| fgetpos | | | |
| fseek | | | |

Тривиально копируемый объект это:
1. объект скалярного типа (арифметические, перечислительные и указатели)
2. тривиально копируемый класс

Тривиально копируемый класс это класс, который:
- имеет хотя бы один подходящий конструктор копирования, конструктор копирования перемещения, оператор присваивания копирования, или оператор присваивания перемещения
- каждый из перечисленных выше элементов тривиален (т.е. не предоставлен пользователем и у типа нет виртуальных методов и виртуального класса-родителя + конструкторы всех полей тривиальны и конструкторы всех родительских классов тривиальны)


Перечисленные функции являются унаследованными от языка Си и не рекомендуются к использованию без явной на то необходимости. 
## 10. Типы данных – простые и составные. Агрегирование данных.
## 11. Указатели и ссылки в языке С++. Семантика копирования и перемещения.
## 12. Функции в языке С++. Понятие метода. Рекурсия.
## 13. Указатели на функции в языке С++.
## 14. Библиотечные модули пользователя. Назначение модуля. Структура модуля. Синтаксис и назначение разделов модуля. Пример.
## 15. Программирование статистических и динамических библиотек. Подключение в различных средах.
## 16. Статические и динамические структуры данных. Последовательности и динамические массивы. Реализация операций над последовательностями.
## 17. Линейные списки – основные операции. Реализация списков на основе динамических структур.
## 18. Двусвязный список и его программная реализация. Кольцевые списки. Упорядоченные списки и перестройка списков.
## 19. Понятие стека. Операции над стеком. Программная реализация стека на основе статического массива.
## 20. Понятие очереди. Операции над очередями. Кольцевая очередь. Деки. Программная реализация очереди на основе статического массива.
## 21. Использование очередей при реализации запросов ввода-вывода Структура данных «список».
## 22. Программная реализация очереди на основе статического массива.
## 23. Многократный поиск на основе использования статистических данных.
## 24. Нечеткий поиск – поиск «подобной» подстроки. Бинарный поиск.
## 25. Рекурсия: общий вид, свойства, проблемы. Стек вызова функций.
## 26. Сортировки – общая классификация. Сортировки с помощью включения, выделения, обменов.
## 27. Шейкерная сортировка. Сортировка Шелла.
## 28. Сортировка Хоара – алгоритм QuickSort. Сортировка слиянием.
## 29. Бинарные деревья – основные понятия. Основные операции с бинарными деревьями.
## 30. Понятие рекурсивного типа данных.
В информатике рекурсивными типами данных называются типы данных, которые могут содержать значения, принадлежащие этому же типу данных. Примером может служить структура Node, представляющая собой узел односвязного списка.
```cpp
struct Node{
    T value;
    Node* next;
}
```
Также рекурсивным типом данных считается узел дерева.
```cpp
struct TreeNode{
    std::pair<K,V> kv;
    TreeNode* parent;
    TreeNode* left;
    TreeNode* right;
}
```
## 31. Поиск и включение для деревьев. Исключение для деревьев.
## 32. Сбалансированные деревья. Сортировка с помощью бинарных деревьев (кучи).
## 33. Графы и возможные формы их описания. Нахождение кратчайшего пути на графе.
## 34. Алгоритм Дейкстры, алгоритм Форда.
## 35. Графовые алгоритмы – обзор.
## 36. Хеширование, проблемы коллизий.
## 37. Методы обработки коллизий в хешировании.
## 38. Хеш-таблица на основе перемешанной таблицы
## 39. Хеш-таблица на основе связанных списков
## 40. Построение обратной польской записи выражения.
## 41. Подходы и инструменты к отладке исходного кода
## 42. Директивы подпрограмм. Неявная рекурсия. Пример.
