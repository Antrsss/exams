# Вопросы к ОАиПу сиквел

## 1. Понятие сложности алгоритма, оценки времени исполнения.
### Временная сложность
Временная сложность алгоритма определяется как функция от размера данных и равна времени работы алгоритма на данном вводе.  
Чаще всего выражается в нотации Ландау (О-большое), в которой учитываются только слагаемые высших порядков и не учитываются константные множители. Такое определение временной сложности называется асимптотическим. Асимптотическая оценка временной сложности алгоритма корректна только для ввода, размер которого стремится к бесконечности.  
Временная сложность вычисляется путем подсчета количества элементарных операций, время выполнения каждой из которых -- О(1).  
В данной нотации существуют также обозначения Θ(n), Ω(n), T(n).
- T(n) обозначает количество всех действий, выполненных алгоритмом 
- Θ(n) обозначает нижнюю оценку. Если алгоритм требует Θ(log(n)) операций, то он требует не менее k*log(n) операций, где k -- некоторая константа.
- O(n) обозначает верхнюю оценку. Если алгоритм требует O(log(n)) операций, то он требует не более k*log(n) операций, где k -- некоторая константа.
- Ω(n) обозночает точную оценку. Если алгоритм требует Ω(log(n)) операций, то он требует не более k1*log(n) операций и не менее k2\*log(n) операций, где k1, k2 -- некоторые константы.

| Название | Время работы (T(n)) | Пример алгоритма|
| --------------- | --------------- | --------------- |
| константное | О(1) | побитовый сдвиг числа на 1 |
| дважды логарифмическое| O(log(log(n))) | интерполяционный поиск при равномерном распределении |
| логарифмическое | O(log(n)) | поиск в двоичном дереве поиска |
| линейное | O(n) | поиск наибольшего элемента в неотсортированном массиве |
| линейно-логарифмическое | O(n*log(n)) | наиболее быстрая сортировка сравнением |
| квадратичное | O(n²) | сортировка пузырьком |
| кубическое | O(n³) | обычное умножение матриц |
| экспоненциальное | 2^P(n)* | *P(n) - произвольный многочлен от n|
| факториальное | O(n!) | решение задачи комивояжера полным перебором |

### Пространственная сложность
Пространственная сложность алгоритма определяется аналагично временной, но показвыает объем используемой памяти. Например если алгоритм не использует дополнительной памяти (или использует ее бесконечно мало в сравнении с размером данных), то его пространственная сложность О(1). Например это нахождение наименьшего элемента в неотсортированном массиве.  
Пространственная сложность O(n^2) может возникнуть, если мы имеем функцию f(x,y), где x, y <= n и ее вычисление -- долгий процесс. Тогда вместо вычисления при каждой необходимости можно завести таблицу размера n*n, и  заполнять ее по необходимости.
## 2. Общая классификация вычислительных алгоритмов.
Под "вычислительными" алгоритмами понимаются алгоритмы, используемые для вычисления некоторых математических объектов. Условно их можно поделить на использующие целочисленные значения алгоритмы и алгоритмы, использующие значения с плавающей точкой.  
Вычислительные алгоритмы также можно разделить по области применения:
| Область применения   | Пример алгоритмов |
|--------------- | --------------- |
| теория чисел, вычисление констант и распространенных функций | проверка числа на простоту, разложение числа на множители |
| решение алгебраических задач   | решение СЛАУ  |
| нахождение корней различных уравнений   | решение диффиренциальных уравнений, задачи линейного программирования   |
| приближенное вычисление функций   | приближение функции методом наименьших квадратов |
| вычислительная геометрия  | задача о нахождении площади произвольного многоугольника или класс задач о взаимном расположении фигур |

>я блять хз что тут еще написать

## 3. Точность представления чисел.
Вещественные числа в языке С++ представлены типами float, double и long double, занимающими 4, 8 и 10 байт соответственно (вообще ldouble занимает 16 байт по причине выравнивание). Данные, хранимые в переменных данных типов в памяти представлены согласно стандарту IEEE754. 
>сами про стандарт пишите, мне впадлу

Таким образом тип float имеет 23 значимых для точности бита, тип double имеет 52, а тип long double -- 64. По этой причине проводить операции сравнения со значениями данных типов следует с осторожностью и по возможности лучше использовать выражения вида:
```cpp
long double x = some_func();
long double a = some_other_funt();
if(x - a > 1e-4){
    do_sth();
}
```
## 4. Строковый тип в С++. Представление в памяти. Автоматическое управление памятью для Си строк и `std::string`.
Для представления текстовых данных в языке Си использовались массивы типа char, называемые Си строками. Индикатором их конца служил символ '\\0'. В языке С++ также можно пользоваться строками данного формата, но для повышения удобства работы с текстовыми данными стандартная библиотека содержит класс `std::string`. Данный класс содержит указатель на хранимый текст а также размер строки и объем выделенной памяти. Если для `std::string` автоматическое управление памятью реализованно с помощью механизмов ООП, таких как конструктор и деструктор, которые инкапсулируют выделение памяти, то автоматизация управления памятью для Си строк возможна через механизм умных указателей.  
Умные укзазатели представляют собой класс-обертку над обычным указателем. Существует три вида умных указателей: `unique_ptr`, `shared_ptr`, `weakй_ptr`.
### unique_ptr
`unique_ptr` представляет собой умный указатель, единолично владеющий своим ресурсом. Таким образом никакой другой указатель не может указывать на этот же объект (можно сделать 2 юник_птр из двух сишных поинтеров на один и тот же объект, но это УБ, моветон и долбоебизм). Поэтому данный класс реализует только конструктор перемещения и оператор присваивания-перемещением. Поведение при перемещении определено явно.
### shared_ptr
`shared_ptr` представляет собой умный указатель с разделенным владением. На объект может ссылаться неограниченное число `shared_ptr` и `weak_ptr`, при уничтожении последнего `shared_ptr` на объект (выход из области видимости, ручное удаление) память, выделенная на него освобождается. Для этого в каждом экземпляре хранится счетчик, показывающий количество указывающих на объект `shared_ptr`. 
### weak_ptr
`weak_ptr` представляет собой умный указатель с разделенным владением. Он создан для решения проблемы зацикливания в динамических структурах. Представим ситуацию:   
Имеется двусвязный список с подобной структурой:
```cpp
struct Node{
    std::shared_ptr<Node> next;
    std::shared_ptr<Node> prev;
    T value;
};
```
Тогда если мы захотим удалить некоторый постфикс данного списка мы просто сменим указательв последнем нужном узле на `nullptr`. Но тогда возникнет проблема. 
Первый элемент постфикса не удалится, потму что на него ссылается следующий элемент. Но тогда не удалится и следующий. Получаем утечку памяти.   
Для решения данной проблемы были созданы слабые указатели. Перепишем узел следующим образом:
```cpp
struct Node{
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;
    T value;
}
```
При потере последнего `shared_ptr` на объект он удалится независимо от количества слабых указателей на него.  
Производительность программ с использованием умных указателей отличается от программы использующей обычные указатели незначительно (единственное место потерь это подсчет ссылок в `shared_ptr`)
## 5. Файлы. Двоичное и текстовое представление файлов. Стандартные файлы.
Файл - именованый набор байт, записанный на некотором носителе. Для работы с файлами в языке С++ определены потоки ввода-вывода.

>определение потока из следующего надо сюда вставить.

Файл можно представить в виде текста в некоторой кодировке. Подобное представление файла называется текстовым.
Наименьшей смысловой единицей в таких файлах служит один символ. Они обеспечивают удобство работы с текстовыми данными, но неэффективны, если требуется хранитьданные не текстового формата. 
Например запись числа 255 в кодировке utf-8 займет в текстовом формате 3 байта.   
Также файл можно представить как набор байт. В данном формате можно хранить данные напрямую в их двоичном представлении, от этого и название "бинарный файл".
Данный вид файлов позволяет хранить данные более эффективно, например запись числа 255 займет всего 1 байт.
Однако эта эффективность достигается ограничениями на работу. Например нужно либо ввести разделитель -- некоторый символ, или  последовательность байт, обозначающую конец элемента, либо знать точное количество байт, на которых записана нужная информация.
## 6.  Понятие потока. Открытие и закрытие файлов. Операции ввода-вывода. Указатель чтения-записи в файле.
### Понятие потока
Поток (тот что английский `stream`, не `thread`) - абстракция, представляющая собой устройство ввода/вывода. В общем и целом это бесконечный поток байт, который является либо источником, либо назначением. 
Чаще всего потоки связаны с физическим источником данных (файл, клавиатура, консоль). 
В языке С++ потоки буфферизированы, то есть имеют буффер, который хранит в себе введенную/выведенную информацию некоторое время после операции и только потом записывает/считывает ее. Например если посмотреть за файлом `text.txt` во время выполнения данного фрагмента кода, можнно заметить, что после записи в поток файл обновится не сразу.
```cpp
std::ofstream os;
os.open("text.txt");
os << "AAAAAAAAAAA"; //<- смотрим здесь
os.flush(); //<- и здесь
```
Сделано это для оптимизации, так как множественное обращение к файлу для чтения/записи затратно. Поэтому поток буфферизирует ввод/вывод.
### Открытие/закрытие файлов
Для потоков открытие файлов происходит с помощью метода open класса `basic_fstream`.
Данный метод вызывается с параметрами `filename` и `mode`, где первый это полное имя файла, второй -- режим открытия. 
| Константа   | Суть |
|--------------- | --------------- |
| app   | append, открыть для дозаписи в конец |
| binary   | открыть в режиме двоичного файла |
| in   | открыть для записи |
| out   | открыть для чтения |
| trunc | удалить содержимое файла при открытии |
| ate | выставить начальную позицию для записи в конец|
| noreplace | не позволяет открыть файл, если он существует, но не указаны флаги app или ate   |

>разница между ate и app заключается в том, что ate выставляет указаетль в конец однократно, а app перед каждой операцией ввода

Режимы открытия представлены числовыми константами.
### Операции ввода-вывода
Для совершения операций ввода-вывода для потоков перегружены операторы `>>` и `<<`, для потоков ввода и вывода соответственно.
Для потоков ввода-вывода определены таже форматирующие метод, флаги и манипуляторы (если надо опять писать про эти модификаторы сиаута я хочу умереть)
### Указатель чтения-записи в файле
Указатель чтения-записи представляет собой 64-разрядное значение смещения от начала файла до следующего байта для чтения-записи.
При открытии файла данное значение устанавливается равным нулю если не было установлено иное правило.

## 7. Проверка операций ввода-вывода. Пример.
без комментариев пока что
## 8. Функции для модификации содержимого файла: futc, getc, feof, fputs, fgets, fprintf, fscanf, rewind.
| Функция   | Сигнатура | Возвращаемое значение |Пояснение    |
|--------------- | --------------- |--------------- | --------------- |
| fputc   | int fputc(int ch, FILE* stream)   | значение записанного символа (при успехе), EOF при неудаче, также выставляет индикатор ошибки в потоке |   записывает символ в Си поток в позицию, соответствующую текущему значению указателя ввода-вывода|
| fgetc  |  int fgetc(FILE* stream) |  прочитанный символ или EOF (в случае достижения конца файла выставляет индикатор EOF, в ином случае индикатор ошибки)|считывает следующий символ из потока по указателю ввода-вывода и переводит его в следующую позицию|
| feof | int feof(FILE* stream)   |  ноль, если не был достигнут конец потока, иначе не ноль| проверка на EOF (End Of File кто не знал вдруг)|
| fputs   | int fputs(const char* str, FILE* stream) |  при успехе неотрицательное значение, при неудаче EOF и выставляет индикатор ошибки   |записывает все символы строки str кроме нуль-терминатора в поток|
| fgets   |  char* fgets(char* str, int count, FILE*)   |  str в случае успеха, nullptr в случае неудачи   |читает не более `count - 1` символов из потока и записывает их в массив символов представленный параметром `str`. При встрече символа перехода на следующую строку чтение обрывается и в строку записывается символ перехода на следующую строку. Если байты были прочитаны, записывает в конец строки нуль-терминатор|
| fprintf   | int fprintf(FILE* stream, const char* format, ...)  |  количество записаных символов при успехе, отрицательное число при ошибке| записывает данные в поток в соответствии с форматом, указанным в параметрах |
| fscanf   | int fscanf(FILE* stream, const char* format, ...) |  количество считаных аргументов в случае успеха, EOF в случае ошибки | считывает данные из потока, интерпретирует их в соответствии с форматирущей строкой |
| rewind   |  void rewind(FILE* stream) | void | переводит указатель ввода-вывода в начало потока (эквивалентна fseek(stream, 0, SEEK_SET), но дополнительно очищает идентификаторы ошибки и конца файла);    |

Перечисленные функции являются унаследованными от языка Си и не рекомендуются к использованию без явной на то необходимости. 

## 9. Функции для модификации содержимого файла: ferror, fwrite, fread, fileno, filelength, chsize, ftell, fgetpos, fseek.
| Функция   | Сигнатура | Возвращаемое значение |Пояснение    |
|--------------- | --------------- |--------------- | --------------- |
| ferror | int ferror(FILE* stream) | ненулевое значение если установлен идентификатор ошибки, иначе 0 | проверяет поток на ошибку |
| fwrite | size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream) | количество записаных объектов <= `count` | записывает `count` объектов байтами, размер объекта указывается в `size`. Если объект не является тривиально копируемым, то поведение не определено|
| fread | size_t fread(void* buffer, size_t size, size_t count, FILE* stream) | количество считаных объектов| считывает count объектов из потока, каждый в виде массива байт. Если объект не является тривиально копируемым, то поведение не определено |
| fileno | int fileno(FILE* stream)| системный дескриптор файла при успехе, иначе -1 и выставит идентификатор ошибки | возвращает дескриптор файла (как же я хочу чтобы меня при изучении С++ спрашивали про сишные функции, еще и с ОСной хуйнёй типа дескрипторов 🥰 кста почему-то этой функции нет на cppreference, хотя она существует до сих пор...) |
| filelength | long _filelength(int fd) | длина файла, ассоциированого с переданным дескриптором в байтах| читай возвращаемое значение. Отличие от filesize() в том, что файл должен быть открыт. Данная функция не включена в стандарт и вообще существует только на винде. Какого дьявола она забыла в вопросах к экзамену, когда одно из требований было сдавать лабы на линуксе... |
| chsize | int _chsize(int fd, long size) | 0 если размер был изменен успешно, -1 при ошибке + выставляет индикатор ошибки | изменяет размер файла с дескриптором `fd` на `size`. Какого хуя опять виндовская хуйня, ну что это вообще такое|
| ftell   | long ftell(FILE* stream)| указатель ввода-вывода при успехе, иначе -1| возвращает значение указателя ввода-вывода, для бинарного файла это колчичество байт от начала файла|
| fgetpos | int fgetpos(FILE* stream, fpos_t* pos) | 0 при успехе, иначе ненулевое значение + выставляет индикатор ошибки| записывает указатель ввода-вывода в `pos`, данное значение имеет смысл только как аргумент для fsetpos|
| fseek | int fseek(FILE* stream, long ofset, int origin) | 0 при успехе, иначе ненулевое значение| устанавливает указатель ввода-вывода для переданного потока на `offset` от `origin`|

Тривиально копируемый объект это:
1. объект скалярного типа (арифметические, перечислительные и указатели)
2. тривиально копируемый класс

Тривиально копируемый класс это класс, который:
- имеет хотя бы один подходящий конструктор копирования, конструктор копирования перемещения, оператор присваивания копирования, или оператор присваивания перемещения
- каждый из перечисленных выше элементов тривиален (т.е. не предоставлен пользователем и у типа нет виртуальных методов и виртуального класса-родителя + конструкторы всех полей тривиальны и конструкторы всех родительских классов тривиальны)

Значения `origin`:
- SEEK_SET -- поиск от начала
- SEEK_CUR -- поиск от текущей позиции указателя ввода-вывода
- SEEK_END -- поиск от конца файла


Перечисленные функции являются унаследованными от языка Си и не рекомендуются к использованию без явной на то необходимости. 
## 10. Типы данных – простые и составные. Агрегирование данных.
### Система типов в C++
Тип данных -- атрибут объекта, определяющий какого рода данные могут храниться в объекте, представление данных в памяти и операции, проводимые над данными типами данных. Т.е. он характеризует множество допустимых значений и набор допустимых операций.   
Стандарт C++ представляет следующий вариант классификации типов:
- фундаментальные:
    - `void`
    - `nullptr_t`
    - арифметические типы данных:
        - целочисленные (в т.ч. `bool`, символьные типы)
        - вещественные (типы с плавающей запятой)
- составные:
    - ссылочные типы (`lvalue`- и `rvalue`-ссылки)
    - типы указателей (указатели на объекты и на функции)
    - типы указателей на член (указатель на поле (член с данными) и на метод (функция-член))
    - типы массивов (забавный факт на день: `std::array` не является типом массива)
    - типы функций (`std::function`, лямбды и классы с перегруженным оператором `()` не относятся к типам функций)
    - типы перечислений
    - типы классов (в том числе и объединения)

Стоит учесть, что в представленном выше списке под типом имеется в виду cv-квалифицированная версия если не сказано обратное

### Агреатные типы
Агрегатным типом называется массив или класс без пользовательских или унаследованных конструкторов, без базовых классов и виртуальных функций, без `private` и `protected` нестатических данных и без инициализации по умолчанию для членов.

## 11. Указатели и ссылки в языке С++. Семантика копирования и перемещения.
### Указатели
Указателем в языке C++ называется число размера равного разрядности операционной системы, обозначающее адрес в памяти некоторого объекта или функции (а точнее адрес первого байта объекта). Указатель на объект может быть получен путем присваивания возвращаемого значения оператора `&`, примененного к любому выражению объектного типа (объектный тип -- не функциональный тип, не ссылочный тип и не void) или обращением к полю класса, тип которого является указателем, а также путем применения оператора `new`.   
### Ссылки
Ссылкой называется псевдоним для уже существующего объекта или функции. Различают `lvalue`- и `rvalue`-ссылки.
#### lvalue-ссылки
`lvalue`-ссылкой называется ссылка на `lvalue`-выражение. К `lvalue`-выражениям относятся (да начнется пиздец):
- имя переменной, функции, объект шаблонного параметра или члена вне зависимости от типа. 
- вызов функции, возвращаемое значение которой -- `lvalue`-ссылка 
- `a = b`, `a += b` и все другие встроенные операторы присваивания и составного присваивания
- `++a` и `--a` (встроенный пост-инкремент и декремент)
- `*p`
- `a[n]` и `p[n]`, где a -- lvalue-массив, p -- указатель
- `a.m`, если m не является перечислением или нестатическим методом или если a -- 'rvalue', m нестатический член объектного типа
```cpp
struct foo{
    enum bar{
        m
    };
};

void baz(){
    foo a;
    a.m = 52; //Ошибка, a.m не lvalue 
}
```
- `p->m` аналогично `a.m`
- строковый литерал `"Hello, World!"`
- тернарный оператор `a? b:c`, если `b`, `c` -- `lvalue` одного типа
- выражение приведения к `lvalue`-ссылке `static_cast<int&>(x)`
`lvalue`-ссылки ведут себя как псевдонимы для объекта, на который ссылаются.

#### rvalue-ссылки
Аналогично `rvalue`-ссылкой называется ссылка на `rvalue`-выражение. К ним относятся:
- prvalue:
    - литералы (кроме строковых)
    - вызов функции, возвращаемое значение которой не `lvalue`-ссылка
    - `a++` и `a--`
    - все встроенные арифметические, логические выражения и выражения сравнения (`a + b`)
    - `&a`
    - `a.m` и `p->m`, если `m` -- нестатический метод или перечисление
    - `this`
    - приведение к нессылочному типу `static_cast<int>(x)`
    - лямбда
- xvalue (expiring value)
    - `a.m`, где `a` -- `rvalue`, а `m` -- нестатический член
    - вызов функции(оператора), возвращаемое значение которой -- `rvalue`-ссылка
    - приведение к `rvalue`-ссылке `static_cast<int&&>(x)`
    - `a[n]`, где `a` -- `rvalue` массив
### move-семантика  
С C++ 11 появилась  возможность продлить время жизни временных объектов до времени жизни ссылки на них. Вместе с этим появилась возможность забирать ресурс у временного объекта вместо его копирования т.к. временный ресурс все равно будет уничтожен при выходе из конструктора.
Для реализации данного поведения была введена семантика перемещения.
```cpp
class A{
    int* resource = nullptr;
    A(A&& a){
        std::swap(this->resource, a.resource);
    }
    A&(A&& a){
        delete[] this->resource;
        std::swap(this->resource, a.resource);
        return *this;
    }
}
```
Как видно из примера конструктор копирования просто перемещает владение ресурсом данному экземпляру класса и очищает переданную ссылку. Это позволяет избежать ненужного копирования в подобных ситуациях:
```cpp
std::string s1 = "AAA";
std::string s2 = "BBB";
std::string s3(s1 + s2);
```
Ресурсы `s3` будут перемещены из результата конкатенации так как в копировании нет смысла.   
Но если наш класс имеет более сложные поля, например строки, то нам поможет функция `std::move`. Данная функция переводит свой аргумент к `rvalue`-ссылке
```cpp
class B{
    std::string field;
    int* resource = nullptr;
    B(B&& b): field(std::move(b.field)){
        std::swap(this->resource, b.resource);
    }
    B&(B&& b){
        this->field = std::move(b.field);
        std::swap(this->resource, b.resource);
        return *this;
    }
}
```
>Важно: если не был определен конструктор перемещение, передача `rvalue`-ссылки в конструктор приведет к копированию (если конструктор копирования не был явно удален, но это уже вообще пиздец)
+ пранк на сладенькое
```cpp
void func(const int& x){
    std::cout << "I'm a lvalue reference";
}
void func (int&& x){
    std::cout << "I'm a rvalue reference";
}

int main(){
    int&& ref{6};
    func(ref);
}
```
## 12. Функции в языке С++. Понятие метода. Рекурсия.
### Функции в языке С++
**Функция** в C++ — это именованный блок кода, который выполняет определенную задачу и может быть вызван из других частей программы. Функции помогают структурировать код, делая его более читаемым и управляемым, а также позволяют избежать дублирования кода.
#### Объявление и определение функции
Функция должна быть объявлена перед тем, как её можно будет использовать. Объявление функции (прототип) включает в себя тип возвращаемого значения, имя функции и список параметров. Определение функции включает тело функции.
```cpp
// Объявление функции (прототип)
int sum(int a, int b);

int main() {
    // Немного кода
    return 0;
}

// Определение функции
int sum(int a, int b) {
    return a + b;
}
```
### Понятие метода
Метод — это функция, которая является частью класса. Методы определяются внутри класса и имеют доступ к его данным и другим методам. Методы могут быть обычными, статическими и константными.

- **Обычные методы** имеют доступ к данным конкретного объекта класса.
- **Статические методы** принадлежат классу, а не конкретному объекту. Они могут вызываться без создания экземпляра класса.
- **Константные методы** не изменяют состояние объекта.
```cpp
class MyClass {
public:
    void defaultMethod() {
        // Код
    }
    static void staticMethod() {
        // Код
    }
    void constMethod() const {
        // Код
    }
};

int main() {
    MyClass obj;
    obj.defaultMethod(); // Вызов обычного метода
    MyClass::staticMethod(); // Вызов статического метода
    obj.constMethod(); // Вызов константного метода
    return 0;
}
```
### Рекурсия
Рекурсия — это способ определения функции, при котором функция вызывает саму себя. Рекурсивные функции используются для решения задач, которые можно разбить на несколько подзадач того же типа.

Рекурсивная функция обязательно должна иметь базовый и рекурсивный случаи.
- Базовый случай - это условие выхода из рекурсии, где функция перестает вызывать саму же себя.
- Рекурсивный случай - это условие, в котором функция вызывает саму себя.
#### Пример рекурсивной функции - вычисление факториала числа
```cpp
int factorial(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
```

## 13. Указатели на функции в языке С++.
**Указатель на функцию** (function pointer) хранит адрес функции. По сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции.

Самым распространенным указателем на функцию является ее имя. С помощью имени функции можно вызывать ее и получать результат ее работы.

Но также указатель на функцию мы можем определять в виде отдельной переменной с помощью следующего синтаксиса:

`тип (*имя_указателя) (типы_параметров);`
- **тип** представляет тип возвращаемого функцией значения.
- **имя_указателя** представляет произвольно выбранный идентификатор в соответствии с правилами о наименовании переменных.
- **параметры** определяют типы параметров через запятую (при их наличии).

Указатель может указывать только на такую функцию, которая имеет тот же возвращаемый тип и типы параметров, что и определение указателя на функцию.

`void (*message) ();`
В данном случае определен указатель, который имеет имя **message**. Он может указывать на функции без параметров, которые возвращают тип void (то есть ничего не возвращают).

Пример использования:
```cpp
#include <iostream>
 
void hello() {
    std::cout << "Hello, World" << std::endl;
}
void goodbye() {
    std::cout << "Good Bye, World" << std::endl;
}
  
int main() {
    void (*message)();  // определение указателя на функцию
      
    message=hello;
    message();
    message = goodbye;
    message();
}
```
Также допустимо такое обращение к указателю на функцию:

`(*message)();`

## 14. Библиотечные модули пользователя. Назначение модуля. Структура модуля. Синтаксис и назначение разделов модуля. Пример.
## 15. Программирование статистических и динамических библиотек. Подключение в различных средах.
## 16. Статические и динамические структуры данных. Последовательности и динамические массивы. Реализация операций над последовательностями.
## 17. Линейные списки – основные операции. Реализация списков на основе динамических структур.
## 18. Двусвязный список и его программная реализация. Кольцевые списки. Упорядоченные списки и перестройка списков.
## 19. Понятие стека. Операции над стеком. Программная реализация стека на основе статического массива.
## 20. Понятие очереди. Операции над очередями. Кольцевая очередь. Деки. Программная реализация очереди на основе статического массива.
## 21. Использование очередей при реализации запросов ввода-вывода Структура данных «список».
## 22. Программная реализация очереди на основе статического массива.
## 23. Многократный поиск на основе использования статистических данных.
## 24. Нечеткий поиск – поиск «подобной» подстроки. Бинарный поиск.
## 25. Рекурсия: общий вид, свойства, проблемы. Стек вызова функций.
## 26. Сортировки – общая классификация. Сортировки с помощью включения, выделения, обменов.
## 27. Шейкерная сортировка. Сортировка Шелла.
## 28. Сортировка Хоара – алгоритм QuickSort. Сортировка слиянием.
## 29. Бинарные деревья – основные понятия. Основные операции с бинарными деревьями.
## 30. Понятие рекурсивного типа данных.
В информатике рекурсивными типами данных называются типы данных, которые могут содержать значения, принадлежащие этому же типу данных. Примером может служить структура Node, представляющая собой узел односвязного списка.
```cpp
struct Node{
    T value;
    Node* next;
}
```
Также рекурсивным типом данных считается узел дерева.
```cpp
struct TreeNode{
    std::pair<K,V> kv;
    TreeNode* parent;
    TreeNode* left;
    TreeNode* right;
}
```
## 31. Поиск и включение для деревьев. Исключение для деревьев.
## 32. Сбалансированные деревья. Сортировка с помощью бинарных деревьев (кучи).
## 33. Графы и возможные формы их описания. Нахождение кратчайшего пути на графе.
## 34. Алгоритм Дейкстры, алгоритм Форда.
## 35. Графовые алгоритмы – обзор.
## 36. Хеширование, проблемы коллизий.
## 37. Методы обработки коллизий в хешировании.
## 38. Хеш-таблица на основе перемешанной таблицы
## 39. Хеш-таблица на основе связанных списков
## 40. Построение обратной польской записи выражения.
## 41. Подходы и инструменты к отладке исходного кода
## 42. Директивы подпрограмм. Неявная рекурсия. Пример.
